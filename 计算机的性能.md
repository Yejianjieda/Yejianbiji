# 计算机的性能

## 计算机性能

**定义：**

论起在执行特定任务时的效率和能力。根据用户不同，需求不同，处理的东西不同，所要求的性能是不一样的。

1. **`响应时间`**：从用户发起一个指令或请求到系统完成该请求并给出反馈所需要的时间。包括硬盘访问、内存访问、I/O活动、操作系统开销和cpu执行时间
2. **`吞吐率(带宽)`**：衡量系统在一定时间内恩能够处理多少工作量的能力、通常以每秒处理的任务数量或者数据传输量来表示

···························································

硬件的时间度量概念：----->晶振(石英晶体震荡期)------>主脉冲信号	

计算机性能看时间，越快越吊 

1. **`时钟周期`**：几乎所有计算机都用时钟来驱动硬盘中发生的各种事件，时钟间隔的时间称为时钟周期。单位通常是纳秒(ns),微秒(μs)，或者毫秒(ms).
2. **`时钟长度`**：每个时钟周期持续的时间长度
3. **`时钟频率(主频)`**：即时钟周期的倒数，表示单位时间内时钟周期的数量，通常以赫兹(Hz)为单位，`10Hz`表示每10秒/次

主频=1/时钟周期           时钟周期=1/主频

hz khz mhz ghz thz进制是1000

存储容量 文件大小----2^10    速率 频率 1000

## CPU性能

CPU性能：CPU性能是一个核心指标。**CPU(执行)时间**，及程序在CPU上运行所需要的时间，是CPU性能的关键。

*****cpu(中央处理器)时间 : 用户CPU时间(执行用户程序)  + 系统CPU时间(操作系统提供服务)

**CPU执行时间 = CPU时钟周期数  x  时钟周期时间**

时钟频率(主频)和时钟周期时间互为倒数关系

**CPU执行时间 = CPU时钟周期数 / 时钟频率**

硬件设计者可以通过减少程序的CPU时钟周期数或者降低时钟周期时间来提高性能。然而，在实际的设计过程中，设计者经常需要在这些因素之间进行权衡。因为很多技术在减少时钟周期数的同时，可能会导致时钟周期时间的增加

## 指令性能

指令性能：CPI (clock cycle per instruction) 表示执行每条指令所需的时钟周期数的**`平均值`**。

**CPU时钟周期数=程序的指令数 * CPI**

**CPU时间 = 指令数 * CPI * 时钟周期时间**

**CPU时间 = （指令数 * CPI） / 主频**

上式表明，CPU的性能(CPU执行时间)取决于三个要素:主频、CPI 和指令条数。主频、CPI和指令条数是相互制约的。例如，更改指令集可以减少程序所含的指令条数，但同时可能引起CPU结构的调整，从而可能会增加时钟周期的宽度(降低主频)。

CPU时间：可以通过写程序来测量

主频：看说明书，固定在电路板上的

所以，在衡量一个计算机的好坏的时候，我们要把全部的三个因素全部都考虑进去才行。而不是只讨论其中一个：

![image-20240901233031843](C:\Users\20655\AppData\Roaming\Typora\typora-user-images\image-20240901233031843.png)

IPS：(指每秒可以执行多少条指令)KIPS MIPS

### 408考研喜欢

**有一种用 MIPS (million instructions per second, 每秒百万条指令**）取代时间以度量性能的方法。对于一个个给定的程序， MIPS 表示为：

**MIPS=指令条数（个）/ (执行时间x10^6)=主频 / (CPI * 10^6)。因为是百万条所以×1e6****

1^7hz---->1s=10^7时钟周期

但是 MIPS 规定了指令执行的速率，但没有考虑指令的能力，没有办法用 MIPS 比较不同指令集的计算机，因为指令数肯定是不同的。

1. 主频高的CPU一定比主频低的CPU快吗？---不一定，CPI
2. 如果两个CPU的CPI相同，此时主频高的CPU一定比主频低的CPU快吗--->不一定 指令集架构  乘法 ---->

## 功耗 

：功耗代表了我们需要用多少的代价来进行冷却



在计算机设计中，价格、性能和能耗是三个关键因素。价格反映了计算机的成本和普及程度，性能则决定了计算机能够完成的任务和效率，而能耗则关系到计算机的续航能力和环境影响。最佳的设计应该根据特定的应用领域和需求，在这三个因素之间取得适当的平衡。

并行编程：

