# 有符号数和无符号数

最低有效位表示最右边的意为，最高有效位表示最左边的一位 

计算机硬件设计使得其能够高效的执行给予二进制加法减法乘法出发以及其他逻辑操作，所有这些都直接对应于底层电路中的电子信号的变化，这些基础操作构成了现代计算机计算能力的核心

二进制----十进制

十进制-----二进制

二进制----十六进制

二进制-----八进制 

固定位数  （n+1)的原码范围:

[-(2 n次方-1)，(2 n次方-1)]

0的原码表示有两种：0000 0000 和1000 0000

[][] 当运算的结果超出了该数据类型能够表示的范围时，就会发生溢出。(计算机内部一般用补码存储数据)

## 区分正数和负数：原码

原码加减法：与十进制一样，考虑进位和借位。参与运算的是数值位

在源码加减法中，对于两个不同符号数的加法（或者同符号的减法），先要比较两个数的绝对值大小，然后用绝对值大的数字减去绝对值小的数字，最后还要为结果选取合适的符号

`原码表示法的优点`：
**原码表示的优点是，与真值的对应关系直观、方便,因此与真值的转换简单,并且用原码**
实现乘除运算比较简便。

`原码表示法的缺点`：
**0的表示不唯一,给使用带来不便；加减运算比较复杂，要考虑溢出、负借位等等问题。**

为了简化硬件设计并解决这些问题，现代计算机更倾向于使用**`二进制补码`**（two's complement）的方式来表示有符号整数。二进制补码不仅解决了正负数的区分问题，还使得加减运算能够通过相同的硬件电路实现，同时有效地处理了溢出情况，并消除了正负零的问题。

4位  无符号

1111 

+0001=0000第五位的1直接不要了

由于硬件的位数的限制会自然取余

模运算：
A    B    M 有以下关系

A  =  B  + K  *  M(k是某个整数)

A除M的余数

B除M的余数

同余

mod 12 运算中：
10-4(mod 12)=10+8(mod 12)

位数是n+1 那就是mod 2^n

## 补码

补码：正数的补码是本身，负数的补码是模数减去负数的绝对值

定义：具有一位符号位。n-1位数值位的二进制整数来说，其补码是：
[x]补 = 2^n+x(mod 2^n)     ,  -2^(n-1) <=2^(n-1)

mod 12       10 - 4(mod 12)=10+8_`(8 = 12-4)`_(mod 12)

​	          			**补码**表示正数和负数：
1.正数：**与其原码相同，即最高位（符号位）为0，剩余各位表示数值的绝对值**。
例如，十进制正数5，在8位二进制补码中的表示为： 0000 0101
2.负数：**通过取其绝对值的二进制反码（将所有1变为0，0变为1），然后再加1得到的**。
例如，十进制负数5，在8位二进制补码中的表示为： 1111 1011

原码转补码   数值为按位取反+1

补码转原码也如此

1. 正数的反码与原码相同
2. 负数的原码是对应正数的绝对值的二进制码按位取反

n+1位的二进制补码可以表示范围时 [-(2<sup>n</sup>), (2<sup>n-1</sup>)]

其中，几个特殊数据的补码表示：
（1）[+0]补=[-0]补=000...000(含符号位共n+1个0)，0的补码唯一。
（2）[-2<sup>n</sup>]补=100...000(n个0)，n+1位补码表示的最小整数。
（3）[2<sup>n-1</sup>]补=011...111(n个1)，n+1位补码表示的最大整数。

补码的优势

![image-20240907133212926](C:\Users\20655\AppData\Roaming\Typora\typora-user-images\image-20240907133212926.png)



特殊情况：地址是无符号数

值得注意的是，浮点数在计算机内部通常不是以补码形式存储的，而是遵循IEEE 754标准，该标准使用一种不同的编码方案（符号位、指数和尾数）来表示浮点数。这个会在后面的章节讲解。 





























































