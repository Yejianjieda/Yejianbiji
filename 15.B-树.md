# B-树 多路平衡查找树

B-树是⼀种平衡的多路查找树，注意：B树就是B-树，"-"是个连字符号，不是减号 。在⼤多数的 平衡查找树（Self-balancing search trees)，⽐如 AVL 树 和红⿊树，都假设所有的数据放在主存当中。 那为什么要使⽤ B-树呢（或者说为啥要有 B-树呢）？要解释清楚这⼀点，我们假设我们的数据量达到了 亿级别，主存当中根本存储不下，我们只能以块的形式从磁盘读取数据，与主存的访问时间相⽐，磁盘 的 I/O 操作相当耗时，⽽提出 B-树的主要⽬的就是减少磁盘的 I/O 操作。⼤多数平衡树的操作（查找、 插⼊、删除，最⼤值、最⼩值等等）需要O(h) 次磁盘访问操作，其中h是树的⾼度。但是对于 B-树⽽ ⾔，树的⾼度将不再是logn (其中n是树中的结点个数），⽽是⼀个我们可控的⾼度h（通过调整 B-树中 结点所包含的键【你也可以叫做数据库中的索引，本质上就是在磁盘上的⼀个位置信息】的数⽬，使得 B-树的⾼度保持⼀个较⼩的值）。⼀般⽽⾔，B-树的结点所包含的键的数⽬和磁盘块⼤⼩⼀样，从数个 到数千个不等。由于B-树的⾼度 h 可控（⼀般远⼩于logn），所以与 AVL 树和红⿊树相⽐，B-树的磁盘 访问时间将极⼤地降低。 



B树的度称为阶 m阶B树----

外存和内存进行数据交互 :磁盘 I/O

2-3树 3阶B树

2-3-4树 4阶B树

一个m阶的B树性质：

1。一个结点最多有m棵子树(m个子节点），如果该结点是非根结点，最少ceil(m/2)棵子树。如果 该结点是根结点，最少2棵

子树

2.一个结点内最多m-1个关键字，如果该结点是非根结点，最少ceil(m/2)-1个关键字。如果 该结点是根结点，最少1个关键字

3.每个结点有多个关键字，升序排序。父亲结点和子结点之间数据大小：左边孩子结点的数据<父亲结点中的数据<右边孩子结点的数据------中序遍历序列升序

4.b所有的叶子结点都在同一层（平衡）

5.终端节点：内部节点的最后一层是终端节点。终端节点的孩子是叶子节点（即外部节点）

B树的操作

查找，中序遍历---类似BST

1.插入：法一：回溯法插入 法二：主动插入法 本质是一样的（查找插入位置+插入+分裂上传）

往B树中插入一个关键字k：k最终插入到的位置一定是在一个终端结点上

回溯法插入：先插入 后判断分裂， 基于递归，

第一步：查找k应该插入的节点x 

第二步：按顺序把k插入到结点x中

l=ceil(m/2)-1 r=m-1

第三步：m阶B树结点中关键字的个数[l,r]。此时x结点中多了一个关键字，如果关键字的个数<=r,没关系。但是

如果关键字的个数>r(个数为m了)，把x分裂成两个结点：y，x 

分裂过程：从ceil(m/2)位置分开，后面一半关键字和对应的子树给y，前面一半留给x，把 中间ceil(m/2)位置

的关键字上传到x的父亲结点中。

此时父亲结点也多了一个关键字，对父亲结点进行判断及分裂操作-------

回溯上传的过程

直到某个祖先节点关键字个数<=r或者到了根节点为止。

主动插入法 ：在查找过程中提前主动的把 关键字个数=r的点分裂： 可能做一些多余的分裂，代码要复杂一些

l=ceil(m/2)-1 r=m-1

第一步：查找k应该插入的节点x，但是在查找过程中做一件事：去把查找路径上所经过的关键字个数=r的点分

裂。

第二步：插入k。

2.删除: (兄弟够借则借，不够借就合并)

l=ceil(m/2)-1 r=m-1

删除关键字k

第一步：查找k应该插入的节点x 

分情况讨论：

（1）x是终端节点

（1.1）在x中删除k之后，x中的关键字个数仍>=l,结束

（1.2）兄弟够借：在x中删除k之后，x中的关键字个数<l, 如果左右两个兄弟中，至少有一个兄弟（bro）

关键字个数>l,找这个兄弟借：借的过程：将父亲结点中的关键字下移到x中，将bro中的关键字上移到父亲节点

中

（1.3）左右兄弟不够借：合并兄弟节点以及父亲节点中的关键字。此时父亲节点中的关键字个数少1个，

把父亲节点当作新的被删除的节点，若父亲节点的关键子个数<l,进行调整（1.2）和（1.3）。

（2)x是非终端节点，转化为（1）

找到k的中序遍历后继的关键字k1，以及k1所在的节点x1，用k1替换k，问题转化为删除节点x1中的k1