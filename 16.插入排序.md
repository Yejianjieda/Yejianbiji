# 直接插入排序(Straight insertion Sort)

基本操作：将一个记录插入到已经排好的序的有序表中，从而得到一个新的记录数增为1的有序表

如下图·给定一个无序的数组

1.从第二个数字开始向前比较因为第一个数组本身就是个有序表了6>2大所以位置不用变

2.例如：第三个位数字，和有序表中的数字依次比较找到第一个比本身大的数字（6>3）所以将6及其以后的数字向后移动一个位置，并将3放在6的位置

3.重复2操作最终将得到一个有序数组



代码实现如下

for(int i=2;i<=n;i++)
    {
        k=a[i];
        int j;
        for(j=i-1;j>=1;j--)
        {
            if(a[j]>k)
            {
                a[j+1]=a[j];
             } 
             else{
                 break;
             }

  }
    a[j+1]=k;
 } 



复杂度分析：而在最差的情况下，即第i趟时第i个元素必须与前⾯i个元素都做排序码的比较，并且每做⼀次就叫就要做⼀次数据移动，所以直接插入排序的时间复杂度为O(n^2)

注：插⼊排序不适合对大量量数据进行排序应用，但排序数量级小于千时插入排序的效率还不错，可以考虑使用。

稳定性分析：插入排序是在⼀个已经有序的小序列的基础上，一次插入一个元素。如果碰见⼀个和插入元素相等的，那么将会把待插入元素放在相等元素的后⾯。所以，相等元素的相对的前后顺序没有改变，所以插入排序是稳定的。

折半插入排序(Binary Insertion Sort)
从名字就能看出来，运⽤了二分查找的插入排序。

在上⾯标准的插⼊排序算法中，我们会将待插 ⼊关键字 key = arr[i] ，然后在数组 [0，i - 1] 的范围内查找待插⼊关键字 key 的正确位置，这 ⾥的查找操作的时间复杂度为O(n)量级。但是如果使⽤⼆分查找在数组 arr 的 [0,i - 1] 的范围内查 找关键字 key ，那么就可以将查找操作的时间复杂度降到O(logn)量级。

```cpp
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int low = 0, high = i - 1;
    // 使用二分查找找到插入的位置
    while (low <= high) {
        int mid = (low + high) / 2;
        if (key < arr[mid]) {
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
 
    // 将元素插入到合适的位置
    for (int j = i - 1; j >= low; j--) {
        arr[j + 1] = arr[j];
    }
    arr[low] = key;
}
```

 希尔排序(Shell sort)
我们都理解，优秀的排序算法首要的就是速度，在过去人们想了许多办法都无法将算法的速度，算法的时间复杂度都是O(n^2)，所以当时的计算机学术界充斥着“排序算法无法突破O(n^2)”的声音。而i希尔排序时希尔于1959年提出的一种排序算法，希尔排序是突破这一时间复杂度的第一批算法

基本思想：将原本有大量记录数的记录进行分组，分成若干个子序列，我们知道在记录个数较少时插入排序的效率很高，然后在这些字序列中分别进行差人排序，当整个序列处于基本有序的时候，在对全体记录进行一次直接插入。

基本有序：小弟关键字基本在前面，大的基本在后面，不大不小的基本在中间

排序策略：将相距某个增量d的记录成一个子序列(例如：数组下标{1，4，7}{2，5，8}{3，6，9})，这样才能保证在子序列内分别进行之直接插入排序后得到结果是基本有序而不是局部有序。



 初始增量d=length/2=5，意味着整个数组被分为5组，[8,3],[9,5],[1,4],[7,6],[2,0]。

 

 然后我们对这5组分别进⾏直接插⼊排序，结果就变成

 

 可以看⻅例如3，5，6这些⼩元素就在前⾯了，然后缩⼩增量d = 5/2 = 2，将数组分成两组

 

 对以上的两组再分别进⾏直接插⼊排序，结果如下。此时整个数组的有序程度就更近⼀步了。

 

 再缩⼩增量，d=2/2=1.此时整个数组为1组。[0,2,1,4,3,5,7,6,9,8]。

 

 此时，只需要对以上数列简单微调。⽆需⼤量的移动操作即可完成整个数组的排序

 ```cpp
for(int d=n/2;d>=1;d=d/2)  
    {
        k++;//计算趟数 
        //以增量d分组，对每组进行直接插入排序
        for(int i=1+d;i<=n;i++)
        {
            t=a[i];
            int j;
            for(j=i-d;j>=1;j=j-d)
            {
                if(a[j]>t)
                {
                    a[j+d]=a[j];
                }
                else{
                    break;
                }
            }
             a[j+d]=t;    
         } 
     } 
 ```



 时间复杂度分析：在最坏的情况下，当增量序列为递减序列1, n/2, n/4, …, 1时，希尔排序的最坏时间复杂度为O(n^2)。希尔排序的时间复杂度取决于增量序列的间隔大小以及数组的初始排序情况，究竟取什么样的增量最好，至今仍是一个难题，但大量研究数据表明当递增数列d[k]=2的t-k+1的次方-1时(0<=k<=t<=[log(n+1)])时可以取得加不错的效率O(n^3/2)。

注：增量的最后一定要为1才行

稳定性：由于希尔排序是跳跃性的移动所以，它并不是一个稳定的排序算法

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/YeJianjieda/article/details/135916005