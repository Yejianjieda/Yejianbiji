# 最小生成树

## 生成树的定义

一个连通图的生成树是一个极小的联通子图，它包含图中全部的n个顶点

但是只有构成的一棵树有n-1条边

![image-20240908131153285](C:\Users\20655\AppData\Roaming\Typora\typora-user-images\image-20240908131153285.png)

### 生成树的属性

⼀个连通图可以有多个⽣成树；

⼀个连通图的所有⽣成树都包含相同的顶点个数和边数；

⽣成树当中不存在环；

移除⽣成树中的任意⼀条边都会导致图的不连通， ⽣成树的边最少特性；

！！！！在⽣成树中添加⼀条边会构成环。

对于包含n个顶点的连通图，⽣成树包含n个顶点和n-1条边；

！！！！对于包含n个顶点的⽆向完全图最多包含 n^（n-2）颗⽣成树。

## 克鲁斯卡尔算法**Kruskal算法**（点多边少的图）

​		克鲁斯卡尔算法（Kruskal）是⼀种使⽤贪婪⽅法的最⼩⽣成树算法。该算法初始将图视为森林， 图中的每⼀个顶点视为⼀棵单独的树。⼀棵树只与它的邻接顶点中权值最⼩且不违反最⼩⽣成树属性 （不构成环）的树之间建⽴连边。

利用并查集来检查是否会形成环

**边的处理**: 遍历所有边，对于每条边：

- 使用查找操作检查该边的两个端点是否在同一个集合中。
- 如果不在同一个集合中，则将这条边加入到最小生成树，并合并这两个集合。
- 如果在同一个集合中，则跳过这条边，因为它会形成环。



![image-20240908131955842](C:\Users\20655\AppData\Roaming\Typora\typora-user-images\image-20240908131955842.png)



例如此图，首先我们先按照权值从小到大来对边进行排序

然后逐步逐渐向内添加边

1. 先添加4-7这条边，然后判断是否会有环形成，未成环，添加进去

2. 再添加2-8这条边 发现不能成环 添加

3. 。。。。

4. 。。。

5. 选择5-6这条边时发现如果添加会成环，舍弃添加

6. 选择1-2这条边时 会成环  舍弃 

7. 选择6 - 7 未成环   添加

   当已经添加的边达到顶点个数-1时 停止添加



### 是否存在环

要判断添加⼀条边 X-Y 是否形成环，我们可以判断顶点X在最⼩树中的终点与顶点Y在最⼩⽣成树

中的**终点是否相同**，如果相同则说明存在环路，否则不存环路，从⽽决定是否添加⼀条边。

 所谓**终点**，就是将所有顶点按照从⼩到⼤的顺序排列好之后；某个顶点的终点就是"与它连通的最

⼤顶点"。看下图，我们可以对图中顶点进⾏排序，排序后的顶点存放在⼀个数组中，每⼀个顶点则对应

⼀个下标，同样的我们针对排序后的数组创建⼀个顶点的终点数组，初始时图中的每⼀个顶点是⼀棵

树，每⼀个顶点的终点初始化为⾃身，我们⽤0来表示。

![image-20240908133528563](C:\Users\20655\AppData\Roaming\Typora\typora-user-images\image-20240908133528563.png)

每次添加边将终点作为起点的父亲，如果不断遍历发现二者最终的儿子是同一个的话，那么如果该边添加进去一定会形成环

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#define INF 65535



//邻接矩阵存图--带权无向图 
int g[105][105];//假设最多有100个点
int nv, ne;

//边数组
typedef struct {
    int u, v;//两个端点在邻接矩阵中的下标 
    int w;//权值 
}Edge;
Edge e[5005];
void sorte(int l, int r)
{
    int minn;
    Edge tmp;
    for (int i = l;i < r;i++)
    {
        minn = i;
        for (int j = i + 1;j < r;j++)
        {
            if (e[minn].w > e[j].w)
            {
                minn = j;
            }
        }
        tmp = e[i];
        e[i] = e[minn];
        e[minn] = tmp;

    }
    printf("按权值升序排列：\n");
    for (int i = 0;i < r;i++)
    {
        printf("(%d %d) %d\n", e[i].u, e[i].v, e[i].w);
    }

}
int find(int* f, int x)
{
    if (x == f[x])
    {
        return x;
    }
    else {
        return f[x] = find(f, f[x]);
    }
}
void Kruskal()
{
    int f[105];//并查集的父亲数组
    for (int i = 0;i < nv;i++)
    {
        f[i] = i;
    }
    printf("以下是组成最小生成树的边：\n");
    for (int i = 0;i < ne;i++)
    {
        int fu = find(f, e[i].u);
        int fv = find(f, e[i].v);
        if (fu != fv)
        {
            f[fv] = fu;//合并
            printf("(%d %d) %d\n", e[i].u, e[i].v, e[i].w);
        }

    }

}
int main()
{
    scanf("%d %d", &nv, &ne);
    //邻接矩阵初始化 
    for (int i = 0;i < nv;i++)
        for (int j = 0;j < nv;j++)
        {
            if (i == j)
            {
                g[i][j] = g[j][i] = 0;
            }
            else
            {
                g[i][j] = g[j][i] = INF;
            }
        }
    //s输入边，建图
    int x, y, wi;
    for (int i = 0;i < ne;i++)
    {
        scanf("%d %d %d", &x, &y, &wi);
        g[x][y] = g[y][x] = wi;
        e[i].u = x;
        e[i].v = y;
        e[i].w = wi;
    }
    sorte(0, ne);
    Kruskal();

    return 0;

}

/*
测试用例：讲义上的图
9 15
0 1 3
0 5 4
1 6 6
6 5 7
1 2 8
1 8 5
2 8 2
2 3 12
8 3 11
6 3 14
6 7 9
5 4 18
3 7 6
7 4 1
3 4 10
*/






```

## 贪心算法

在该算法中涉及到了一中算法----贪心算法

顾名思义，贪⼼算法总是作出在当前看来最好的选择。也就是说贪⼼算法并不从整体最优考虑，所谓的贪心算法是一种思想，意为当前问题的局部最优解，而我们熟知的动态规划是指的全局最优解

它所作出的选择只是在某种意义上的局部最优选择。当然，希望贪⼼算法得到的最终结果也是整体最优

的。虽然贪⼼算法不能对所有问题都得到整体最优解，但对许多问题它能产⽣整体最优解。如单源最短

路经问题，最⼩⽣成树问题等。在⼀些情况下，即使贪⼼算法不能得到整体最优解，其最终结果却是最

优解的很好近似。

贪⼼算法的基本要素：

 1、贪⼼选择性质。所谓贪⼼选择性质是指所求问题的整体最优解可以通过⼀系列局部最优的选

择，即贪⼼选择来达到。这是贪⼼算法可⾏的第⼀个基本要素，也是贪⼼算法与动态规划算法的主要区

别。

 动态规划算法通常以⾃底向上的⽅式解各⼦问题（后⾯会讲），⽽贪⼼算法则通常以⾃顶向下的

⽅式进⾏，以迭代的⽅式作出相继的贪⼼选择，每作⼀次贪⼼选择就将所求问题简化为规模更⼩的⼦问

题。

 对于⼀个具体问题，要确定它是否具有贪⼼选择性质，必须证明每⼀步所作的贪⼼选择最终导致

问题的整体最优解。

 2、当⼀个问题的最优解包含其⼦问题的最优解时，称此问题具有最优⼦结构性质。问题的最优⼦

结构性质是该问题可⽤动态规划算法或贪⼼算法求解的关键特征。



































